;; 03 March 2008
;; 
;; Yuri Arapov <yuridichesky@gmail.com>
;; 
;; Project Euler
;; 
;; http://projecteuler.net/index.php?section=problems&id=29
;;
;; Problem 29
;; 25 October 2002
;; 
;; Consider all integer combinations of ab for 2 ≤ a ≤ 5 and 2 ≤ b ≤ 5:
;; 
;;    2^2=4 , 2^3=8  , 2^4=16  , 2^5=32
;;    3^2=9 , 3^3=27 , 3^4=81  , 3^5=243
;;    4^2=16, 4^3=64 , 4^4=256 , 4^5=1024
;;    5^2=25, 5^3=125, 5^4=625 , 5^5=3125
;; 
;; If they are then placed in numerical order, with any repeats removed, we get
;; the following sequence of 15 distinct terms:
;; 
;; 4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125
;; 
;; How many distinct terms are in the sequence generated by ab for 2 <= a <= 100
;; and 2 <= b <= 100?
;;
;; Answer:
;;      9183 (brute force)
;;      9183 (!!!)


(define (divisor? d n) (zero? (remainder n d)))
;; return true if d is n's divisor


(define (mk-factor base power)  (cons base power))
(define (factor-base f)         (car f))
(define (factor-power f)        (cdr f))
(define (factor->number f)      (expt (factor-base f) (factor-power f)))
(define (factors->number ff)    (apply * (map factor->number ff)))


(define (print-factor f)
  (display (factor-base f))
  (display "^")
  (display (factor-power f)))


(define (factor-divide-power f d) 
  (mk-factor (factor-base f) 
             (/ (factor-power f) d)))


(define (factorize n)
;; decompose number n into primes so that
;;
;;       p1     p2
;; n = b1   * b2   * ...  (where bi is a prime and pi is its power)
;;
;; return list of factors (see above) that represent such decomposition
;;
  (define (append-factor ls p pwr)
    (if (zero? pwr)
      ls
      (append ls (list (mk-factor p pwr)))))
  
  (define (loop ls p pwr n)
    (if (eqv? n 1)
      (append-factor ls p pwr) ;; done
      (if (divisor? p n)
        (loop            ls               p     (+ pwr 1)  (/ n p))    ;; increase power and go on
        (loop (append-factor ls p pwr) (+ p 1)      0         n   )))) ;; add factor to the list and go on

  (loop '() 2 0 n)) ;; '2' is first prime


(define (factorization->base ff)
;; convert factorization ff into 
;;
;;   d                 p1     p2         d
;;  b  form, so that b1   * b2  * ... = b 
;;
;;  where b is the smallest possible number
;;  and b1, p1, b2, p2, etc. are factors stored in ff list
;;
  (let* ((d (apply gcd (map (lambda (x) (factor-power x)) ff)))
         ;; d is greatest common divisor of all the powers of the factors
         ;; in ff list

         (bf (map (lambda (x) (factor-divide-power x d)) ff))
         ;; bf is a list of factors made from ff by dividing each
         ;; factor's power by d

         (base (factors->number bf)))
         ;; base is a number computed as a product of factors from
         ;; bf list (i.e. base is result of de-factorization of bf list)

    (mk-factor base d)))


;; test code
(define (qq)
  (factorization->base (factorize (* 256 81))))


(define (repower p0 p1)
;; return (p0' p1') pair so that
;;
;;   0 < p0' < p0
;; and
;;   p0' * p1' = p0 * p1
;; and
;;   p0' is greatest possible number
;;
  (define (loop p0 pp)
    (if (zero? p0)
      (cons 1 pp)
      (if (divisor? p0 pp)
        (cons p0 (/ pp p0))
        (loop (- p0 1) pp))))
  (loop (- p0 1) (* p0 p1)))


(define (p29-run amin amax bmin bmax)
;; Project Euler's problem 29
;;

  (define (distinct? a b)
  ;;                 b
  ;; return true if a  is distinct number,
  ;;
  ;; i.e there are no x and y so that
  ;;
  ;;    b    y
  ;;   a  = x
  ;;
  ;; where x < a and y <= bmax
  ;;
  ;; formulae:
  ;;
  ;;     b       b0  b       b1  b2
  ;;    a  = ( a0   )  = ( a0   )   
  ;;
  ;;    where b0*b = b1*b2 
  ;;    and   b2 >= b
  ;;
    (let* ((a0b0    (factorization->base (factorize a)))
           (b0      (factor-power a0b0))
           (b1b2    (repower b0 b))
           (b2      (cdr b1b2)))
      (or (eqv? b2 b) (> b2 bmax))))

  (define (loop n a b)
    (if (> a amax)
      n
      (if (> b bmax)
        (loop n (+ a 1) bmin)
        (if (distinct? a b)
          (loop (+ n 1) a (+ b 1))
          (loop    n    a (+ b 1))))))

  (loop 0 amin bmin))


(define (p29) (p29-run 2 100 2 100))

;; (display (p29))


;; end of file
