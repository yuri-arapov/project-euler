#!/usr/bin/python
# 
# Project Euler
#
# http://projecteuler.net/index.php?section=problems&id=12
#
# Problem 12
# 08 March 2002
#
# The sequence of triangle numbers is generated by adding the natural numbers.
# So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first
# ten terms would be:
#
# 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
#
# Let us list the factors of the first seven triangle numbers:
#
#       1: 1
#       3: 1,3
#       6: 1,2,3,6
#      10: 1,2,5,10
#      15: 1,3,5,15
#      21: 1,3,7,21
#      28: 1,2,4,7,14,28
#
# We can see that the 7th triangle number, 28, is the first triangle number to
# have over five divisors.
#
# Which is the first triangle number to have over five-hundred divisors?
#
# Answer:
#


import sys


def number_of_combinations(n, k):
# return number of k-subsets in the set of n size
# http://en.wikipedia.org/wiki/Combinations
        c, d = 1, 1
        for i in range(n):
                c *= k-i
                d *= i+1
        return c / d
# end of number_of_combinations


def number_of_divisors(x):
        if x == 1:
                return 1
        p = []
        divisor = 2
        sys.stdout.write("primes: ")
        while x != 1:
                if (x % divisor == 0):
                        # divisor is a prime
                        pp = 0
                        while x % divisor == 0:
                                sys.stdout.write("%d " % (divisor))
                                x /= divisor
                                pp += 1
                        p.append(pp)
                divisor += 1
        sys.stdout.write("| ")

        # now p is an array containing number of each prime
        # that are divisors of the x
        #
        # example:
        #   let x be 28, so the primes list will be
        #   (2 2 7)
        #
        #   and so the p array will contain
        #   (2 1), where
        #     2 is number of '2's in primes list,
        #     1 is number of '7's in primes list

        N = 0

        for i in range(len(p)):
                np = p[i]
                no = 0
                for j in range(i+1, len(p)):
                        no += p[j]
                nn = 0
                for k in range(2, no+1):
                        nn += number_of_combinations(no, k)
                N += nn * np

        return len(p) + N + 2
# end of number_of_primes


# main

i, x = 1, 1


while 1:
        sys.stdout.write("%16d " % (x))
        sys.stdout.flush()

        nd = number_of_divisors(x)

        sys.stdout.write("%d " % (nd))
        sys.stdout.write("\n")

        if nd > 500:
                break

        i += 1
        x += i

print x

# end of file
