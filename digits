number-digits.scm:1:;; number-digits.scm
number-digits.scm:7:;;   (number->digits 123) : (3 2 1)
number-digits.scm:10:(define (number->digits n)
number-digits.scm:22:          (number->digits (quotient n 10)))))
number-digits.scm:24:;;(define (number->digits n)
number-digits.scm:27:;;    (cons (number->digits (quotient n 10)) (list (remainder n 10)))))
p113.scm:142:(define (number->digits n)
p113.scm:145:    (append (number->digits (quotient n 10)) (list (remainder n 10)))))
p113.scm:149:  (let ((nn (number->digits n)))
p113.scm:157:(define (number->diff n)
p113.scm:159:             (nn   (number->digits n)))
p113.scm:167:  (let loop ((diff (number->diff n)))
p113.scm:174:  (let loop ((diff (number->diff n)))
p30.scm:31:(define (number->digits n)
p30.scm:40:  (apply + (map digit-powers (number->digits n))))
p32.scm:25:(define (number->digits n)
p32.scm:28:    (cons (remainder n 10) (number->digits (quotient n 10)))))
p32.scm:35:;;       (iter (append ls (number->digits (car nn))) (cdr nn))))
p32.scm:36:;;   (iter (number->digits a) z))
p32.scm:37:  (fold (lambda (n res) (append res (number->digits n))) 
p32.scm:38:        (number->digits a) 
p34.scm:23:(load "number-digits.scm")
p34.scm:47:    (apply + (map digit->factorial (number->digits n))))
p35-2.scm:28:(define (number-of-digits n)
p35-2.scm:31:    (+ 1 (number-of-digits (quotient n 10)))))
p35-2.scm:56:    (let* ((digits     (number-of-digits n))
p35.scm:27:(define (number-of-digits n)
p35.scm:30:    (+ 1 (number-of-digits (quotient n 10)))))
p35.scm:47:  (let* ((digits     (number-of-digits n))
p36.scm:30:  (let* ((ls       (string->list (number->string n base)))
p37.scm:39:  (string->number (list->string (cdr (string->list (number->string n 10))))))
p38.scm:40:(define (number-of-digits n)
p38.scm:43:    (+ 1 (number-of-digits (quotient n 10)))))
p38.scm:46:(define (number->digits n)
p38.scm:49:    (append (number->digits (quotient n 10)) (list (remainder n 10))))) ;; 123 -> (1 2 3)
p38.scm:50:;;    (cons (remainder n 10) (number->digits (quotient n 10))))) ;; 123 -> (3 2 1)
p38.scm:54:  (let ((l (quick-sort (number->digits n)
p38.scm:63:      (let ((res-len (number-of-digits res))
p38.scm:83:           (len   (number-of-digits iprod)))
p39-2.scm:60:(define (number-of-right-triangles p)
p39-2.scm:75:      (let ((n (number-of-right-triangles p)))
p40.scm:42:(define (number->digits n)
p40.scm:47:;;   (number->digits 123) -> (1 2 3)
p40.scm:51:    (append (number->digits (quotient n 10)) 
p40.scm:67:    (list-ref (number->digits number) x)))
p49.scm:33:(define (number->digits n)
p49.scm:36:    (append (number->digits (quotient n 10)) (list (remainder n 10)))))
p49.scm:114:         (b (map (lambda (x) (list x (sort-digits (number->digits x)))) a))
p52.scm:26:(define (number->digits n)
p52.scm:29:    (cons (remainder n 10) (number->digits (quotient n 10)))))
p52.scm:37:  (equal? (sort-digits (number->digits a))
p52.scm:38:          (sort-digits (number->digits b))))
p55.scm:56:             (n (reverse-and-add (number->digits n))))
p55.scm:95:(define (number->digits n)
p55.scm:101:    (cons (remainder n 10) (number->digits (quotient n 10)))))
p56.scm:25:(load "number-digits.scm")
p56.scm:41:                  (max r (apply + (number->digits (expt a b)))))))))
p5.scm:28:(define (split-number-into-primes n)
p5.scm:64:      (iter (union ll (split-number-into-primes from)) (+ from 1) to)))
p63.scm:20:(define (number-of-digits n)
p63.scm:41:            (if (= (number-of-digits (expt n pwr)) pwr)
p66.scm:47:(define (number->cont-fraction n maxlen)
p66.scm:94:  (abs (- (cont-fraction->number (number->cont-fraction n maxlen)) n)))
p66.scm:171:           (a   (number->cont-fraction srd 30))
p71.scm:28:  (define (number->int x) (inexact->exact (round x)))
p71.scm:34:        (iter (number->int (* res dd)) (number->int (* 3/7 dd)) dd x)))
p92.scm:30:(define (number->digits n)
p92.scm:33:    (cons (remainder n 10) (number->digits (quotient n 10)))))
p92.scm:42:  (let ((dd (number->digits limit)))
p92.scm:47:(define (number->square-of-digits n)
p92.scm:48:  (apply + (map (lambda (x) (* x x)) (number->digits n))))
p92.scm:54:         (nn (number->square-of-digits ll))
p92.scm:65:                     (loop (number->square-of-digits n)))
p92.scm:77:                      (if (loop (number->square-of-digits n))
